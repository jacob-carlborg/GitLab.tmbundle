<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>autoScrollOutput</key>
	<true/>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>command</key>
	<string>#!/usr/bin/env ruby20

require ENV['TM_BUNDLE_SUPPORT'] + '/bundle/bundler/setup'
require ENV['TM_SUPPORT_PATH'] + '/lib/tm/htmloutput'

require 'pp'
require 'erb'
require 'gitlab'
require 'httparty'

Gitlab.configure do | config |
  config.endpoint = 'http://gitlab.a.snowmen.se/api/v3'
  config.private_token = ENV['TM_GITLAB_PERSONAL_ACCESS_TOKEN']
end

def Gitlab.build_trace(project, id)
  options = {}
  client.send(:set_authorization_header, options)
  url = @endpoint + "/projects/#{url_encode(project)}/builds/#{id}/trace"
  client.validate HTTParty.get(url, options)
end

class Git
  def last_commit
   @last_commit ||= `git log -n 1 --format='%H'`.strip
  end
end

class AnsiToHtml
  COLORS = {
    '1' =&gt; 'bold',
    '30' =&gt; 'black',
    '31' =&gt; 'red',
    '32' =&gt; 'green',
    '33' =&gt; 'yellow',
    '34' =&gt; 'blue',
    '35' =&gt; 'magenta',
    '36' =&gt; 'cyan',
    '37' =&gt; 'white',
    '90' =&gt; 'grey'
  }

  def to_html(string)
    s = StringScanner.new(string.gsub("&lt;", "&amp;lt;"))
    out = ''
    open_span = false
    while(!s.eos?)
      if s.scan(/\e\[(3[0-7]|90|1)(;1)?m/)
        style = COLORS[s[1]].dup
        style &lt;&lt; ' bold' unless s[2].nil?
        out &lt;&lt; %{&lt;span class="#{style}"&gt;}
        open_span = true
      elsif s.scan(/\e\[0K/)
        # noop
      elsif s.scan(/\n\e\[0;m/)
        out &lt;&lt; %{&lt;br&gt;}
        out &lt;&lt; %{&lt;/span&gt;} if open_span
        open_span = false
      elsif s.scan(/\e\[0;m/)
        out &lt;&lt; %{&lt;/span&gt;}
        open_span = false
      elsif s.scan(/\n/)
        out &lt;&lt; %{&lt;br&gt;}
      else
        out &lt;&lt; s.scan(/./m)
      end
    end

    out
  end
end

class GitLabCIBuild
  PROJECT = 'trading/emo'

  HTML_HEADER = &lt;&lt;-HTML
    &lt;style type="text/css" media="screen"&gt;
      .bold {
        font-weight: bold;
      }
      .black {
        color: black;
      }
      .red {
        color: #c66;
      }
      .green {
        color: #05a20b;
      }
      .yellow {
        color: yellow;
      }
      .blue {
        color: blue;
      }
      .magenta {
        color: magenta;
      }
      .cyan {
        color: cyan;
      }
      .white {
        color: white;
      }
      .grey {
        color: grey;
      }
    &lt;/style&gt;
  HTML

  class Status
    CREATED = 'created'
    PENDING = 'pending'
    RUNNING = 'running'
    FAILED = 'failed'
    SUCCESS = 'success'
    CANCELED = 'canceled'
    SKIPPED = 'skipped'

    def self.done?(status)
      case status
      when FAILED, SUCCESS, CANCELED, SKIPPED
        true
      else
        false
      end
    end
  end

  def initialize(git)
    @git = git
    @prev_trace = ''
    @ansi = AnsiToHtml.new
  end

  def bold(string)
    "&lt;b&gt;#{string}&lt;/b&gt;"
  end

  def build_subtitle(build)
    build_id = bold('#' + build.id.to_s)
    pipeline_id = bold('#' + build.pipeline.id.to_s)
    commit = bold(build.commit.short_id)
    ref = bold(build.pipeline.ref)
    author = bold(build.commit.author_name)
    "Build #{build_id} in pipeline #{pipeline_id} for commit #{commit} from #{ref} by #{author}"
  end

  def build_title(build)
    "Build ##{build.id} - #{build.commit.title}"
  end

  def html_output(build, &amp;block)
    options = { title: 'Build Output', html_head: HTML_HEADER }

    if build
      options[:title] = build_title(build)
      options[:sub_title] = build_subtitle(build)
    end

    TextMate::HTMLOutput.show(options) do |io|
      io &lt;&lt; '&lt;pre&gt;'
      begin
        block.call(io)
      ensure
        io &lt;&lt; '&lt;/pre&gt;'
      end
    end
  end

  def invoke
    $stdout.sync = true
    begin
      build = last_build
    rescue Gitlab::Error::Error =&gt; e
      html_output(build) { |io| io &lt;&lt; e.message }
      exit
    end

    html_output(build) do |io|
      loop do
        build = last_build
        new_trace = self.send(:new_trace, build)
        html = ansi.to_html(new_trace)
        io &lt;&lt; html unless html.empty?

        break if Status.done?(build.status)
        sleep 0.5
      end
    end
  rescue Gitlab::Error::Error =&gt; e
    puts e.message
  end

  private

  attr_reader :git
  attr_reader :ansi

  def last_build
    Gitlab.commit_builds(PROJECT, git.last_commit, per_page: 1, page: 1).first
  end

  def build_trace(id)
    Gitlab.build_trace(PROJECT, id)
  end

  def diff(s1, s2)
    s1 ||= ''
    s2 ||= ''

    return '' if s1 == s2
    index = s2.chars.zip(s1.chars).index { |a, b| a != b }
    a = s2[index .. -1]
    a
  end

  def new_trace(build)
    trace = build_trace(build.id)
    new_trace = diff(@prev_trace, trace)
    @prev_trace &lt;&lt; new_trace
    new_trace
  end
end

GitLabCIBuild.new(Git.new).invoke
</string>
	<key>contentMatch</key>
	<string>action.scm.other</string>
	<key>input</key>
	<string>none</string>
	<key>inputFormat</key>
	<string>text</string>
	<key>keyEquivalent</key>
	<string>@y</string>
	<key>name</key>
	<string>Build Output</string>
	<key>outputCaret</key>
	<string>afterOutput</string>
	<key>outputFormat</key>
	<string>html</string>
	<key>outputLocation</key>
	<string>newWindow</string>
	<key>scope</key>
	<string>attr.scm.git</string>
	<key>uuid</key>
	<string>060E2CA3-E64F-4F19-A4CA-F9B4AA3EA272</string>
	<key>version</key>
	<integer>2</integer>
</dict>
</plist>
